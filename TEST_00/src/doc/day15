# day15

Object 클래스

	2. toString()
		==> 자바는 주소를 내부적으로 사용하고 있다
			하지만 주소를 사용자(개발자)에게 노출하지는 않는다
			
			대신 주소를 출력하면 
				"클래스이름@해쉬코드값"
			의 형태로 출력한다
			
			참고]
				해쉬코드
				==> 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리한다
					해쉬코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다
					
			문제]
				주소를 출력하려고 하는 순간
					==> Object obj = new Object();
						이 때 obj에는 Object의 객체의 주소가 기억이 될 것이고
						System.out.println(obj);
						라는 명령으로 출력을 하게 되면
						이 때 toString() 가 자동 호출이 된다
						
			결론]
				toString()는 주소를 출력할 때 자동 호출되어서
				출력할 내용을 만들어주는 함수이다
				
				따라서 우리는 만든 클래스를 출력할 때
				우리가 원하는 내용으로 고쳐 써서(오버라이드 해서) 사용하면 된다
				
				참고]
					public void toString(String str) {
						System.out.println(str);
					}
					==> 오버로딩
					
	3. clone()
		==> 자기 자신을 깊은 복사해주는 함수
		
			주의]
				이 함수는 접근지정자가 protected 이므로
				상속받은 클래스나 같은 패키지의 클래스에서만 사용할 수 있다
				
	4. hashCode()
		==> 자바는 주소를 노출하지 않기 위해서
			해쉬테이블을 이용해서 주소를 관리한다
			그 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수
			
-------------------------------------------------

String 클래스와 StringBuffer 클래스의 차이점

	String 클래스는 문자열을 변경하게 되면
	매번 Heap 영역에 객체를 생성하게 되므로 메모리 낭비가 극심해진다
	따라서 이렇게 문자열의 수정이 빈번한 경우에는
	StringBuffer나 StringBuilder 를 사용해서 처리해주는 것이 좋다
	단, StringBuffer나 StringBuilder를 사용해서 문자열 수정을 마치게 되면
	반드시 String 타입으로 변경시켜주는 것이 좋다
	<== 자바에서 사용하는 거의 대부분의 함수들의 매개변수가 
		String 타입의 데이터를 입력해달라고 원하기 때문
	
	이 때 String 타입의 데이터로 변경시켜주는 함수가
		toString()
	함수이고, 역시 Object 클래스의 toString() 함수를 오버라이딩 해놓은 함수이다
	
------------------------------------------------
숙제]
	String, StringBuffer, StringBuilder 소속의 함수를
	각각 10개 이상 조사하고 예제를 만들어보세요
	
-------------------------------------------------

Math

==> 주로 수학적인 기능을 처리하는 함수로 구성되어 있는 클래스
	모든 함수가 static 이므로 굳이 new 시키지 않아도 사용할 수 있는 함수들이고
	아예 new 시키지 못 하도록 해놓은 클래스이다
	
-------------------------------------------------

래퍼 클래스(Wrapper Class)

==> 주소를 사용(레퍼런스변수를 사용)하는 곳에 기본데이터타입을 사용할 수 없는 문제가 생긴다
	이런 문제를 해결하기 위해서 만든 클래스를 레퍼클래스(Wrapper Class)라고 한다
	
	예를 들어
		int를 주소(인스턴스)로 사용할 수 있도록 하기 위해 만든 클래스
		
	참고]
		자바는 Object를 중심으로 계층 구조화 해서
		클래스를 이용하도록 만드는 객체지향언어이다
		
		그러나 유일하게 기본데이터타입(Value Type) 만큼은
		객체지향 원리를 사용하지 않는다
		따라서 다형성 구현에 문제가 발생한다
		
		예]
			void abc(Object o) {
			}
			
			==> 이 함수는 모든 내용을 처리하도록 만든 함수이다
				그런데 유일하게 기본데이터타입은 사용할 수 없다
				
		그래서 이런 문제를 해결하기 위해서 만들어진 클래스가 Wrapper Class 이다
		
		종류]
			Boolean, Character, Byte, Short, Integer, Long, Float, Double
	
	참고]
		Boxing 과 Unboxing
		
			Boxing : 기본데이터타입을 객체타입으로 변환하는 것
			Unboxing : 객체타입을 기본데이터타입으로 변환하는 것
			
			따라서 래퍼클래스란 Boxing과 Unboxing 을 해주기 위한 클래스
			
	참고]
		그런데 이제는 Boxing과 Unboxing을 몰라도 상관없다
		<== 자바 버젼 1.4 이후부터는 Boxing과 Unboxing이 자동으로 처리되기 때문
		
	결론]
		자바는 내부적으로 모든 정보를 주소로(레퍼런스로) 통일해서 사용할 수 있다
		
------------------------------------------------------

java.util 패키지 소속의 유용한 클래스

	1. Objects
	
		==> 이 클래스는 100% static 함수로만 구성되어있는 클래스
			클래스를 다룰 때 유용한 몇 가지 유틸리티적인 함수로 구성된 클래스
			
			예]
				isNull(Object o)
				==> 객체에 내용이 있는지를 확인하는 함수
					new 시킨 결과가 있는지를 확인하는 함수
					
					Object obj;
					
					try {
						####
						obj = new Object();
						xxxx
					} catch(Exception e) {}
					
					==> #### 내용에 따라 obj 행의 명령이 실행될 수도 있고 아닐수도 있음
						이 때 new가 됐는지 안됐는지 확인
						
			*****
			참고]
				null: 주소 변수에 주소가 없는 상태
						이것은 찾아갈 대상이 없다는 말이고,
						이 말은 이것을 아직 사용할 준비가 되어있지 않다는 말이다
						
-----------------------------------------------------

Random Class

	==> 난수를 발생하는 클래스
		우리가 사용해오던 Math.random() 보다는 
		좀 더 다양한 형태의 난수를 발생할 수 있는 장점이 있다
		
		참고]
			seed 란?
				컴퓨터에서 난수를 발생시킨다는 것은
				그 순간 실제로 난수가 발생되는 것은 아니다
				이미 컴퓨터 내부에는 난수 테이블이 존재하고
				컴퓨터는 그 테이블에서 순서대로 데이터를 꺼내서 주는 역할을 한다
				
				seed란 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어이다
				
---------------------------------------------------

Arrays 클래스

	==> 역시 100% static 함수로만 구성된 클래스
		배열을 처리할 때 필요한 유틸리티적인 함수들로 구성된 클래스
		
		예]
			sort()
				==> 배열에 있는 데이터를 정렬하는 기능을 가진 함수
				
--------------------------------------------------
***
정규식 검사

	==> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 잇는지를 확인하는 기능
	
		예]
			주민등록번호는 '6자리-7자리' 의 숫자로만 구성되어 있는가?
			ID가 순수하게 숫자와 문자열로만 구성되어 있는가?
			ID가 최소 몇 글자 이상으로 만들어져 있는가?
			
	사용하는 클래스
	
		java.util.regex.Pattern
			==> 정규식 검사에 사용할 정규식 문법(패턴)을 지정할 클래스
			
		java.util.regex.Matcher
			==> 정규식 검사를 실제로 실행할 클래스
			
	참고]
		정규식 문법]
			1. c[a-z]*
				==> 글자를 특정 위치에 기술하면 반드시 그 위치에 해당 글자가 와야 한다
					[] 안에 기록하면 그 중 하나가 와야 한다
					* 바로 앞의 지정한 글자가 0개 이상 올 수 있다
					
				==> c로 시작하는 소문자 문자열
			
			2. c[a-z]
				==> c로 시작하고, 다음 글자는 반드시 알파벳 소문자이어야 한다
				
			3. c[a-zA-Z]
				==> c로 시작하고, 다음 글자는 반드시 알파벳이어야 한다
				
			4. c[a-zA-Z0-9]
				==> 3번 + 숫자
					이 경우는 줄여서 c\w 로 사용할 수도 있다
					
			5. .*
				==> .은 모든 문자(알파벳과 한글까지 포함)를 의미
				==> 무슨 글자가 와도 상관없다
				
			6. c.
				==> c로 시작하고, 다음 글자는 아무 글자 하나가 오면 된다
			
			7. c.*
				==> c로 시작하고, 다음은 아무 문자나 0개 이상 오면 된다
			
			8. c\.
				==> \. 은 반드시 . 문자만 와야 한다는 의미
				==> 반드시 c.
			
			9. c\d
				==> \d 는 숫자 문자를 의미
				==> c로 시작하고, 다음 글자는 아무 숫자 하나가 오면 된다
				== c[0-9]
				
참고]
	자바에서 문자열 데이터에 큰따옴표를 포함하고 싶을 경우
		('가나다라마바사' 라는 문자열에서 '라마' 앞 뒤에 ""를 붙여서 출력하고 싶은데
		"가나다"라마"바사"	==> 라마 에서 에러남)
	==> 이런 경우 사용하는 문자를 이스케이프 문자라 칭한다
		"가나다"라마"바사"	==>	"가나다\"라마\"바사"
		표현하고 싶은 기호에 역슬래시(\)를 붙여서 문자열에 포함시키는 방법
		
			10. c.*t
				==> c로 시작하고, 다음은 아무 문자나 0개 이상 온 후,
					마지막은 t로 끝나야 한다
				==> "abcdc$tabc" - O. 중간의 c$t 가 조건에 맞음
			
			11. [b|c].*
				==> b나 c로 시작하고,
					다음은 아무 문자나 0개 이상 오면 된다
						[b|c] == [b-c] == [bc]
						
			12. [^b|c]
				==> ^ 는 NOT의 의미
					b 또는 c가 아닌 문자
					
			13. .*a.*
				==> a라는 문자가 포함된 문자열
			
			14. .*a.+
				==> *: 0개 이상
					+: 1개 이상
					
			15. [b|c].{2}
				==> {} 안의 숫자는 글자의 개수를 의미
					b 또는 c로 시작하는 3자리 문자열
					
			16. .{2, 3}
				==> {2, 3}은 글자 수를 의미
					, 는 OR를 의미
					아무 글자나 2 또는 3글자
					
		=== 아래는 자바스크립트 ===
			17. ^c
				==> 문자열의 첫 글자는 반드시 c로 시작해야 한다
				
			18. c$
				==> 문자열 마지막 글자는 반드시 c로 끝나야 한다
				
----------------------------------------------------

Scanner Class
	==> 외부장치를 이용해서 데이터를 받아들이기 위한 클래스
	
		참고]
			원래 자바는 IO라는 개념을 이용해서 외부장치와 연결한다
			그러다보니 간단한 테스트를 위해서도 IO 처리를 해야 하므로
			개발자가 매우 불편했었다
			
			자바버젼 1.5 부터 만들어진 기능이다
			
		생성자함수
			==> 외부장치인 File이나 IO인 Stream을 넣어달라고 하고 있다
		
		참고]
			System.in
				==> 내부적으로 키보드와 연결한 스트림으로 만들어 놓은 것
					
					Scanner sc = new Scanner(System.in);
					==> 키보드를 통해서 입력받는 Scanner가 된 것이다
					
--------------------------------------------------
*
StringTokenizer

	==> 하나의 문자열을 원하는 문자를 기준으로 나누는 기능을 가진 클래스
	
		사용이유]
			네트워크 등을 이용하면 여러 개의 데이터가 한 번에 들어올 수 있다
			
		예]
			카톡을 하면
			카톡을 보낸사람, 보낸시간, 내용, ... 등이
			하나의 문자열로 구성되어서 한 번에 들어온다
			==> 이런 경우 각각의 데이터를 분리해서 처리해야 할 것이다
				보낸사람@보낸시간@내용
		
		생성방법]
			1. StringTokenizer(String str)
				==> 문자열을 공백을 기준으로 나누는 기능
				
			2. StringTokenizer(String str, String delim)
				==> 문자열을 지정한 문자(delim)를 기준으로 나누는 기능
				
			3. StringTokenizer(String str, String delim, boolean returnDelims)
				==> 2번 + 구분문자도 하나의 문자로 처리한다
				
			참고]
				분리된 결과는 임시 버퍼에 기억이 되어있다
				***
				따라서 이것은 특징이 한 번 사용하면 버퍼에서 그 순간 지워버린다
				따라서 한 번 사용하면 더 이상 사용할 수 없게 되고
				***
				반드시 순서대로만 꺼내야 한다
				
			주요함수]
				countTokens()
					==> 문자열을 나눈 결과 수를 반환해주는 함수
				
				hasMoreElements()	/	hasMoreTokens()
					==> 임시버퍼에 내용이 남아있는지 여부를 묻는 함수
				
				nextElement()	/	nextToken()
					==> 버퍼에 있는 데이터를 꺼내는 함수
					
-----------------------------------------------------

BigDecimal
	==> 정수로 표현할 수 없는 숫자를 사용하기 위한 클래스
	
		주로 데이터베이스와 연동할 때
		오라클의 데이터는 number(숫자)
			이 숫자는 38자리까지 사용할 수 있다
		이런 데이터는 자바에서는 처리할 수 없으므로
		이런 유형의 데이터를 처리하기 위해서 만들어진 클래스
		
		예]
			BigDecimal big = new BigDecimal("1234567890123456789012345678901234567");
			
--------------------------------------------------------
*
Date 클래스
	==> 날짜와 시간을 관리하는 클래스
		
		생성자함수]
			Date()
				==> 현재 시스템의 날짜와 시간을 이용해서 관리
			
			나머지 생성자
				==> 지정한 날짜와 시간을 이용해서 관리
		
		참고]
			이 클래스는 Calendar 클래스가 버젼업 버젼이므로
			자바는 Calendar 클래스 사용을 권장하고 있다
			하지만 아직도 Date 클래스를 사용해야 하는 함수가 존재한다
			
--------------------------------------------------------

Calendar Class
	==> Date 클래스를 버젼업 시켜놓은 클래스
	
		생성방법]
			**
			이 클래스는 생성자함수를 감춰놓은 경우에 해당하므로
			스스로 new 시켜서 객체를 만들 수는 없고
			함수 중 속성이 static 이면서 반환값이 Calendar인 함수를 찾아서
			객체를 사용해야 한다
			
			Calendar car = new Calendar()	==> X
			
			Calendar car = Calendar.getInstance();	==> O
			
		주요함수]
			get(int field)
				==> 필요한 정보를 알려주는 함수
					이 함수는 int field에 알고자하는 내용을 알려주면
					그 값에 대해서 알려주는 함수
					
					중요]
						Calendar 클래스는
						각각의 변수가 무엇을 알기 위한 변수인지를 공부해놓는 것이 좋다
						Field Summary를 보세요
						
			getTime()
				==> Calendar 클래스를 Date 클래스로 변환하는 함수
				
					실무에서는 Calendar 클래스를 이용해서 작업을 하다가
					필요하면 Date클래스로 변환해서 사용할 필요가 있다
					왜? 함수들 중 매개변수로 아직 Date타입을 넣어달라고
						선언되어있는 함수들이 있기 때문
					
					예]
						Calendar car = Calendar.getInstance();
						
						...
						
						Date d = car.getTime();
				
				참고]
					자바 API의 함수 이용 방법
					
						자바의 함수를 보면 문자열로 의미하는 내용을
						int로 입력해달라는 함수가 많이 존재한다
						이런 경우는 99%가 자기자신이 가진 그 문자열을 의미하는 숫자를
						담아 놓은 변수를 가지고 있다
						그 변수를 이용해서 처리하면 된다
						
					예]
						showConfirmDialog(Component parentComponent, 
									Object message, String title, int optionType)
						
						==> int optionType은 이미 
							JOptionPane에서 정의해놓은 상수가 존재하고
							그 상수를 입력해주면 된다