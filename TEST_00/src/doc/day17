# day17

Collection Class
	==> 이것은 이름은 컬렉션이지만
		컬렉션은 아니고, 컬렉션을 이용할 때 필요한 부가적인 기능을
		제공하는 유틸리티적인 클래스이다
		
		주의]
			컬렉션을 사용할 때
			List를 달라고 하면(매개변수에 List타입으로 정의가 되어 있으면)
			List 계열을 입력하면 된다
			
			Set을 달라고 하면 Set계열을 입력하면 된다
			
			Collection을 달라고 하는 경우는 List 또는 Set계열 중
			하나를 입력하면 된다
			
			Map을 달라고 하면 Map계열을 주면 된다(조상이 다름)
			
		참고]
			일반적인 정렬은 오름차순 정렬을 하게 된다
			만약 정렬방식을 변경하고자 한다면
			sort(List list, Comparator c) 를 사용해야 한다
			
-----------------------------------------------------------

Set 계열
	특징]
		1. 입력한 순서대로 보관하고 있을 보장이 없다(입력 순서를 보장하지 못 한다)
		(나름의 규칙에 따라서 내부적으로 정렬해서 보관하기 때문)
		
		2. 중복된 데이터는 한 번 만 저장한다
			(중복된 데이터가 입력될 경우에는 먼저 저장된 데이터를 지우고,
			새로운 데이터를 입력한다)
	
종류]
	1. HashSet
		==> HashCode를 이용해서 정렬해서 보관하는 방식의 컬렉션이다
			따라서 우리가 상상하는 정렬은 이루어지지 않는다
			
			'참고도 아니고 몰라도 되는 내용'
			HashSet(int initialCapacity, float loadFactor)
			==> loadFactor - 해쉬코드값을 만드는 규칙에 사용할 상수값을
							사용자가 지정하면서 해쉬테이블을 만들어서 사용한다
							
		*****
		Set 계열은 데이터를 꺼내는 기능은 존재하지 않는다
		==> 왜? 개발자가 데이터가 저장된 장소를 모르기 때문
			따라서 특정 위치를 지정하면서 데이터를 꺼낼 수 없다
			따라서 Iterator로 변환해서 순서대로 꺼내서 사용하도록 하고 있다
	
	2. TreeSet
		==> 내부적으로 Tree Sort라는 알고리즘을 이용해서 데이터를 보관하는 기능을 가진 컬렉션
		
		특징]
			우리가 상상하는 정렬 방식을 이용한다(오름차순, 내림차순)
		
		생성방법]
			TreeSet(Comparator comparator)
			==> 정렬 방식을 변경해서 TreeSet을 만든다
			
			TreeSet(SortedSet<E> s)
			==> TreeSet을 이용해서 다시 TreeSet을 만든다
		
		참고 함수]
			subSet()
				==> 하나의 Set에 담긴 내용 중에서 특정 부분만 골라서
					새로운 Set을 만드는 함수
					
			headSet(E toElement)
				==> 처음부터 지정한 부분까지 골라서 새로운 Set을 만든다
			
			tailSet(E fromElement)
				==> 지정한 부분부터 마지막까지 골라서 새로운 Set을 만든다
				
----------------------------------------------------------

Map
	==> 하나의 데이터를 그 데이터를 구분할 수 있는 키값과 한 쌍으로 만들어서
		데이터를 기억하는 컬렉션의 일종
		그리고 사용할 경우에는 키값을 이용해서 데이터를 꺼낼 수 있도록 해 놓았다
		
		Map 계열은 많은 양의 데이터를 보관하는 용도보다는
		데이터를 쉽게 구분하여 사용할 목적으로 사용된다
	
종류]
	Hashtable / HashMap
		Hashtable이 이전 버젼에서 나온 클래스이고
		HashMap이 다음 버젼에서 나온 클래스이므로
		HashMap을 사용하도록 권장하고 있다
		
		내부적으로 키값을 해쉬테이블을 이용해서 정렬해서 보관한다
		
		주요함수]
			put(Object key, Object value)
			==> 데이터를 입력하는 함수
			
			get(Object key)
			==> 필요한 데이터를 꺼내는 함수
			
		참고함수
			values()
				==> 데이터만 꺼내서 사용할 수 있다
			keys()
				==> 키값만 꺼내서 사용할 수 있다
				
			참고]
				keys()로 꺼낸 데이터는 Enumeration으로 반환한다
				(Enumeration)
				==> 이 클래스는 Iterator의 구버젼이다
					즉, 데이터를 순차적으로 꺼낼 수 있는 것이다
			
			참고]
				HashMap에서는 키값만 꺼내는 함수가 keySet()으로 변경되었다
				
			참고]
				entrySet()
				==> Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다
					(물론 다른 방식으로도 꺼낼 수 있긴 하지만)
					==> 키값과 데이터를 Set으로 묶어주는 함수
				
				문제]
					Map은 항상 두 개가 있어야 저장된다
					Set은 오직 한 개만 저장된다
					따라서 어떻게 해서든지 key와 value를 하나로 묶어야만
					Set에 한 세트로 저장할 수 있다
					
					이것을 해결하기 위해서 클래스(VO)가 존재한다
					그 클래스가 바로
						Map.Entry
					라는 클래스이다
					이 클래스 안에는 key와 value 변수를 은닉화 시켜놓고
					이 변수를 사용할 수 있는 함수를 제공하고 있다
					이 변수들과 이 함수들을 캡슐화 해놓은 클래스이다
					
	TreeMap
		==> TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다
			이 때 정렬 기준은 키값을 이용해서 정렬하게 된다
			따라서 키값이 정렬이 되지 않는 클래스를 사용할 수 없고
			필요하다면 정렬방식을 정해서 사용해야 한다
			
			Temp abc() {
				...
				int a = 10;
				String b = "우현우"
				Temp t = new Temp();
				t.a = a;
				t.b = b;
				return t;
			}
			==> 이처럼 클래스를 보면 가끔 무슨 기능을 필요로 해서 만들어지는 것이 아니고
				다만 여러 개의 데이터를 하나로 묶기 위한 목적으로 만들어 놓은 클래스가 있다
				
			class Temp {
				int a;
				String b;
			}
			==> 이런 클래스를 우리는 데이터 빈 클래스라고 하고
				Value Object(VO) 또는 DTO(Data Transfer Object)
				라고 한다
		
	참고]
		컬렉션 안에는 다시 컬렉션을 입력할 수 있다
		왜? 컬렉션 안에는 모든 클래스를 입력할 수 있으므로
			컬렉션 클래스까지 저장이 가능하다
	
---------------------------------------------------------

Properties
==> Map의 역할을 하는 클래스

	일반 Map과의 차이점은
		파일을(외부장치를) 이용해서 직접 데이터를 읽어서 Map처럼 저장할 수 있고
		Map에 저장된 데이터를 직접 파일(외부장치)로 출력해서 저장할 수 있다
	
	문제점]
		파일의 내용을 읽을 때 엔코딩(encoding)이 되지 않는다
		==> 한글 파일의 경우 파일 자체에서 인코딩을 하지 않으면
			내용이 한글인 경우 한글이 깨져서 들어온다
			
		모든 내용이 문자열로 처리가 된다
		만약 공백이 입력되면 공백도 문자열의 구성으로 간주가 되서 같이 처리한다
		
		"abc" 와 "abc " 는 전혀 다르다
	
	참고]
		한글이 포함된 파일을 Properties에서 사용하기 위해서 인코딩시키는 방법
		
			1. cmd 창을 연다
			2. path를 JAVA_HOME으로 잡아준다
			3. native2ascii 기능을 이용해서 인코딩해준다
			
				형식]
					> native2ascii 현재파일 새로운파일
					==> 인코딩된 새로운 파일을 만들어준다
					
					예]
						>native2ascii d:\sample.twt d:\sample_ko.txt
	참고]
		properties 클래스는 오직 String으로만 키값과 데이터를 처리해야 한다
		
	참고]
		Properties는 이외에도 또 하나의 특징을 가지고 있는데
		현재 프로그램의 정보를 Map으로 자동 처리하는 기능을 가지고 있다
		
-------------------------------------------------------

제너릭스
	==> 컬렉션에 데이터를 입력할 때 입력하는 데이터의 타입을 미리 알려줌으로써
		꺼낼 때 좀 더 편하게(형변환없이) 꺼낼 수 있도록 해주는 것
		<== 컬렉션에는 모든 데이터가 입력되는 동시에
			Object 타입으로 자동형변환이 되어서 저장된다
		
		형식]
			ArrayList<String> list = new ArrayList<String>();
			
			==> list에는 반드시 문자열 데이터만 입력해야 한다
		
		참고]
			제너릭스는 전파되지 않는다
			하나의 컬렉션이 제너릭스 선언이 되더라도
			그 컬렉션을 이용하는 다른 컬렉션에서도 제너릭스가 전파되지는 않는다
			다시 선언해줘야 한다
			
		참고]
			특수한 제너릭스
			
				원래 제너릭스는 특정 클래스만 입력받을 목적으로 사용된다
				
			형식]
				<? super 클래스이름>
					==> 지정한 클래스를 포함해서 상위의 클래스를 모두 허락한다
					
					예]
						ArrayList<? super ArrayList> list = new ArrayList<? supper ArrayList>();
				
				<? extends 클래스이름>
					==> 지정한 클래스를 포함해서 하위 클래스까지 허락한다
						<클래스이름> 의 형식과 같은 개념
			
				이 방법은 제너릭스 선언을 하지 않은 것과 동일한 효과이다
				
---------------------------------------------------------

어노테이션
	==> 내부적으로 약속된 실행을 자동으로 처리하도록 하는 명령의 일종
		
		주로 화면에 실제 보이는 실행이 아니고
		점검을 한다든지, 선언적인 실행(이 클래스는 xxx 로 작동하세요)
		의 의미를 가진 명령을 말한다
	
	형식]
		@명령
		
---------------------------------------------------------
